#!/usr/bin/env python

"""
   ingest
   ~~~~~~

   Ingest turns ESPA generated scenes, turns them into tiles,
   and saves them to Cassandra. It is designed to minimize your
   effort and tell you how things went by logging detailed progress.

   For example, it can take an entire directory that contains
   compressed ESPA generated files:

   python ingest.py "data/*045026*.tar.gz" > ingest.log

"""

import contextlib
import logging
import multiprocessing as mp
import os
import glob
import sys
import tarfile
import tempfile
import traceback

import numpy as np

import click

try:
    from lcmap.version import __version__
except ImportError:
    # Try adding `pwd` to PYTHONPATH
    sys.path.append(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from lcmap.version import __version__

import lcmap.config as config
import lcmap.db.scene
import lcmap.db.tile
from lcmap.ingest.scene import Scene


ch = logging.StreamHandler(sys.stdout)
ch.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.addHandler(ch)
lcmap_logger = logging.getLogger('lcmap')
lcmap_logger.setLevel(logging.DEBUG)
lcmap_logger.addHandler(ch)


@contextlib.contextmanager
def temporarily_expanded(path):
    """Extract an archive to a temporary directory"""

    try:
        # Allocate temporary space. If this does not succeed,
        # we don't even bother with anything else.
        into = tempfile.TemporaryDirectory()
        data = tarfile.open(str(path))
        logger.debug("decompressing {0} to {1}".format(path, into.name))
        data.extractall(into.name)
        yield into.name
    finally:
        # We need to make sure that `into' is actually assigned
        # a value...
        logger.debug("removing extracted files {0}".format(into.name))
        into.cleanup()


def ingest(scene, **kwargs):
    """Tile and save all available bands in scene."""
    band_count = len(scene.bands)
    for idx, band in enumerate(scene.bands):
        progress = "{0} [{2:0>2}/{3:0>2}] {1:<20} "
        logger.info(progress.format(scene.name, band.name, idx + 1, band_count))
        for tile in band.tiles(**kwargs):
            if not np.all(tile['data'] == band.fill):
                lcmap.db.tile.save(**tile)
        band.free()


def expand_and_ingest(file, file_idx, file_count, **kwargs):
    """Multiprocessing friendly tiling function."""
    try:
        with temporarily_expanded(file) as scene_path:
            scene = Scene(scene_path)
            progress = "{0} [{1:0>3}/{2:0>3}] ingest started from {3}"
            logger.info(
                progress.format(scene.name, file_idx, file_count, scene_path))
            ingest(scene, **kwargs)
            logger.info("{0} ingest finished".format(scene.name))
    except Exception as err:
        logger.error("ingest failed {0}: {1}".format(file, err))


@click.command()
@click.argument("source", default="data/*.tar.gz", nargs=-1)
@click.option("--tile-size", default=256)
@click.option("--pixel-size", default=30)
def process(source, **kwargs):
    """Ingest multiple scenes.
    """
    logger.info("Processing started.")
    logger.debug("Keyword args: {}".format(kwargs))
    logger.debug("Source argument: {}".format(source))
    total = len(source)
    logger.debug("Number of source files: {}".format(total))

    for idx, file in enumerate(source):
        expand_and_ingest(file, idx+1, total, **kwargs)

    logger.info("Processing complete.")


if __name__ == "__main__":
    process()
